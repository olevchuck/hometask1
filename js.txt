Ќа ’абре уже разминались и развлекались кажущимис€ нелогичност€ми JavaScript. 
ѕо-моему, такие примеры отличный способ разм€ть мозги после длительных новогодних праздников,
поэтому предлагаю вам подумать над 10 задачками.

ќтветы и свой вариант объ€снени€ почему такое поведение логично
€ буду скрывать под спойлером. —разу оговорюсь, что не претендую на непоколебимую
истину своих версий и буду рад их обсудить.

1. “ак что помните, дети, всегда подставл€ем системы счислени€!

ƒл€ начала простой, но прикольной пример. „то вернут такие вызовы parseInt?
parseInt('fuck');
parseInt('fuck', 16);

–ешение
parseInt('fuck');     // NaN
parseInt('fuck', 16); // 15

 ак работает parseInt: он посимвольно провер€ет переданную строку на соответствие 
указанной вторым аргументом системе счислени€ и если находит некорректный символ,
то завершает работу. ѕо умолчанию, система счислени€ считаетс€ дес€тичной. 
¬ не самых свежих браузерах если переданна€ строка начинаетс€ с 0, то по умолчанию
система считаетс€ восьмеричной. ¬ дес€тичной системе счислени€ символ СfТ недопустим
и функци€ заканчиваетс€ свою работу не найд€ ни одной цифры.
ј вот в шестнадцатиричной системе символ СfТ допустим и соответствует дес€тичному
числу 15. —имвол СuТ не допустим и функци€ завершает свою работу.

2. ћожет кто подскажет?

„ему равно такое выражение?
"Why am I a " + typeof + "";

–ешение
УWhy am I a numberФ

ќператор У+Ф обладает большим приоритетом чем УtypeofФ,поэтому указанна€ запись
эквивалентна следующей:
УWhy am I a Ф + (typeof (+ УФ)).

”нарный У+Ф выполн€ет приведение к числу, поэтому УtypeofФ от результата его
выполнени€ Ч это number.